*Yum* is a mostly Rust-inspired language, with significant planned changes to:
- enums
- traits
- recursively typed pointers


# Enums 

In Yum, enums are true sum types: 

```
struct A {...}

struct B {...}

struct C {...}

enum S {
    A,
    B,
}

enum T {
    A, 
    C,
}
```

We also allow optionally namespacing the variants, closer to Rust style:

```
enum R {
    ::D(A,B)
    C
}
```

Or a convenient syntax sugar for namespacing all variants: 

```
enum N:: {
    P,
    Q,
}
```

Matching works by narrowing the type of the matched expression in the given arm:

```
//t has type T, as defined above

match t {
    A => {
        // t has type A here
    }
    B => {
        // t has type B here
    }
}
```

Though we probably want more sophisticated pattern matching later as well.



# Infras

Infras are Yum's replacement for the Rust trait system. They fill a similar role to traits: acting as bounds for generic type variables, and enable writing generic functions. The main difference is that they can also make references to the data contents of their implementors. 


## Philosophy interlude

Yum has a type system that is generated by:
- primitive types
- structs
- enums
- generics

Since enums are true sum types, every "irreducible" type is actually a struct (or a primitive). Enums are sums over structs and generics just generate structs types (or sums over them).

To an enum, we can also assign the "minimal struct type it conforms to". For example, if

```
struct A {
    x: int,
    y: String,
    z: bool
}

struct B {
    x: int,
    y: String,
    w: bool
}

enum T {
    A,
    B,
}
```

Then the enum type T can be used as a struct type that has the _x: int, y: String_ fields. 


## Infras: introduction

An infra is defined much like a struct:

```
infra I {
    a: int,
    b: String,
}

impl I {
    fn print() {//...}
}
```

We want to use infras for declaring concrete types to be the subtypes of the infra, and thereby inherit the general methods we defined for the infra. We call this _conforming_ to the infra. The basic way to do this is:

```
conform A -> I {
    x -> a,
    y -> b,
}
```

That is, we just make a correspondence from _some_ of the conformee's fields to _all_ of the conformed's fields (the types have to match, of course). This is the basic, solidly planned case of conformance. It's meant to solve the problem that we want names for infra fields (to use them in infra methods), but also we don't want to restrict the "subtypes" of the infra to use the same field names.

Later on, we might add support for making more complicated computations that make the conformation correspondence. The complication here is the following. If we make a unidirectional correspondence, computing I's fields in some complicated way from A's fields, that allows the inheritance of some I-methods, however, if there is a mutator method on I, we cannot pull it back. We can solve that problem by requiring the programmer to define a more complicated conformance: essentially a factoring of A with one of the factors being I, the other some "residual" type, and then also specifying the inverse operation. This allows mutation, but the specified operations being inverses of each other cannot generally be comptime verified.


## Some infra mechanics details

Infra methods do not have self arguments (among other things, matches on them would be problematic since they are essentially an infinite enum). Instead, their fields are available in method bodies through _.fieldname_ syntax. 

Infras and concrete types form a largely two-tiered, segregated system, where infras can freely refer to concrete types but not vice versa. Infras can use both infras and concrete types for type annotations on fields, method arguments, method returns, generic bounds. Concrete types can only use infras for generics bounds and method arguments (these would be monomorphized according to actual usage). 

Enums can also conform to infras. Recall that enums are sums over struct types, therefore if all summands are conformed to an infra, the enum also conforms. Alternatively, the conformance can also be declared by conforming the "minimal struct type" of the enum to the infra.

Conformance is by default transitive, and the compiler can automatically compose conformances A->B and B->C when the user wants A->C conformance. It is also allowed to overwrite the derived conformance with an explicit A->C conformance. This is in fact required when there are multiple conflicting conformance chains connecting A and C (the diamond problem).

Infras can also declare abstract methods that the conformers need to concretely implement, similar to traits. 



# Generics

Generics use infras as type variable bounds, as explained above.
We use square brackets for generics syntax, to avoid the notorious parsing problems, the need for turbofish, etc. Generics are monomorphized, producing the required monomorphizations according to nedd.


# Self-typed pointers, _above_, _scoped_
[TBD]

## NOTES
- scope pointer register in ABI

